# 关于另一种只用作哈希记录的区块链

在本节中，中本聪讨论了一个他认为有趣的建议。这个建议依赖于在区块链中提供更少的信息，目的是提供更高的水平隐私。

### 不是一个建议
> 发帖者：Red，2010年8月10日，上午05:45:45
> ————————————————————————————————————————————————————
> 正如一些人可能已经注意到的那样，让我误解比特币的一个原因是整个交易历史完全是公开的。我完全理解这简化事物的好处，让每个人都能轻松证明币是有效的。
>
> 所以这不是改变比特币的建议。相反，这是一个关于什么是可能的，哪些是不可能的问题。
>
> 一般的问题是，区块列表是否可以以未在列表中存储完整交易的方式实现？具体来说，\*也许\*可以只存储区块列表中的入点、出点的哈希值。这些将在区块列表中加上时间戳(公证)，与现在完全一样。
>
> 主要区别在于币接收者有责任存储完整的交易。也许他可能必须深入存储以前的交易(X)以证明历史。
>
> 当他想将币转移到下一方时，他将完全按照现在的方式创建交易，除非他必须将先前的交易提交进行验证。为了验证，入点的每个先前交易将被散列并验证为块列表中存在的。入点将在块列表中进行散列并标识为尚未花费。然后，交易将按照当前的步骤进行验证。
> 
> 如果一切都经过正确验证，则额外输入/输出点哈希将被添加到块中。这将关闭交易的入点，并将新的出点哈希标记为未使用。
>
> 一旦节点完成区块(通过赢得哈希竞赛)，他然后将哈希块和相关交易+加上以前的交易广播到其他节点以进行确认和接受。
>
> 一个简单的例子是：
> {区块-9
> 哈希-a，哈希-b，哈希-c，哈希-x
> } 
> {区块-12
> 哈希-a，哈希-y，哈希-c，哈希-d
> }
> {区块-17
> 哈希-b，哈希-d，哈希-e，哈希-z，哈希-f
> }
>
> {交易
> {入点：哈希-x，哈希-y，哈希-z}
> {地址，签名和其他交易的东西}
> {出点：哈希支付，哈希变化
> }
>
> {生成区块
> 哈希-x，哈希-y，哈希-z，哈希支付，哈希变化
> }
>
> 所以基本上，如果在区块列表中存在两次入点/出点哈希，那么它就已经花掉了。如果它只存在一次它没有花费。
>
> 所以在区块-17之后：
> a，b，c＆d 花掉了。
> e，f，x，y，z 未花掉。
>
> 这个交易花费了x，y和z，并创建哈希支付和哈希变化，因此交易有效。
>
> 生成区块之后：
> 花费了a，b，c，d，x，y和z。
> e，f，付款，变更未动用。
>
> ====
>
> 目标：
>
> 目标是提供现有系统的所有相同安全性，但避免为每个易于关联的交易创建公共图。在这种情况下，哈希甚至不必在区块中关联。该区块可以简单地按升序对所有哈希值进行排序。
>
> 实际上，我想创造真正的金币。我可以把钱给你，但世界上的每个人都不知道我做了什么。你可以把它们交给下一个人并证明它们是纯金币，因为你有币的谱系，而且谱系中的每一代都在公共记录中公证。
>
> ====
>
> 问题：
> 中本聪表示您可以通过Merkle树结构从区块列表中删除交易，而不会影响安全性。我想我真正的问题是：
>
> “你最早可以删除的交易是什么？”
>
> 你可能认为节点无论如何都能记住一切(网络永远不会忘记)。但是如果你构造协议以便新节点只接收哈希的区块列表，那么他们只能从这一刻开始记住。这会带来一些额外的隐私。(也许)
>
> ====
>
> 有什么想法吗？是否有一种明显的方式可以让人们欺骗和致富?

### 回复：不是一个建议

> 发帖者：Insti，2010年8月10日，上午09:34:14
> ————————————————————————————————————————————————————
> 在您的系统中，我只需要查看每个交易(我将会看到)并将其记录到我的秘密服务器，而不仅是从区块链获取交易。
>
> 你只是含糊的来倡导安全。

### 回复：不是一个建议

> 发布者Red，2010年8月10日，下午02:09:36
> ————————————————————————————————————————————————————
> &emsp; &emsp; 引自：Insti于2010年8月10日上午09:34:14
>
> &emsp; &emsp; 您只是含糊的来倡导安全。
> ————————————————————————————————————————————————————
> 我确实提过了。我不会指望这是为了货币安全。我希望系统等同于当前系统。
>
> 但是，隐私保护会增加价值。你的邻居，或FBI，我可以整天看你做的一切。但他们可能不是。如果你碰巧变得“感兴趣”，那么他们现在可以开始关注你了。
>
> 但最需要额外法律权力的是，“让我检查每个人的日志！”（电话，手机信号塔，电子邮件连接，Facebook连接，信用卡/借记卡交易，谷歌历史记录，浏览器历史记录。）其他系统的“安全通过权利”，但比特币不是。
>
> 顺便说一句，我不愿将每笔交易广播到每个节点。但这是另一件事。
>
> 这是大多数数字公证服务的工作方式。您向他们发送签名文档的哈希值，并将其永久记录。然后他们创建像比特币一样的哈希链。它们定期在报纸或其他脱机冗余中记录发布当前哈希链值。
>
> 您不必将您的私人文件/交易发送给公证人，以便为他们加上时间戳和记录。公证人只是证明此时存在与此哈希相匹配的内容。

### 回复：不是一个建议

> 发帖者：Insti，2010年8月10日，下午03:06:16
> ————————————————————————————————————————————————————
> &emsp; &emsp; 引自：Red，2010年8月10日，下午02:22:09
>
> &emsp; &emsp; 顺便说一句，这是大多数数字公证服务的工作方式。您向他们发送签名文档的哈希值，并将其永久记录。然后他们创建像比特币一样的哈希链。它们定期在报纸或其他脱机冗余中记录发布当前哈希链值。
> 
> &emsp; &emsp; 您不必将您的私人文件/交易发送给公证人，以便为他们加上时间戳和记录。公证人只是证明此时存在与此哈希相匹配的内容。
> ————————————————————————————————————————————————————
> 您也无需向公证人证明您的帐户中有X个BTC可用。
>
> 虽然我最近在阅读有关零知识证明[http://en.wikipedia.org/wiki/Zero-knowledge_proof](http://en.wikipedia.org/wiki/Zero-knowledge_proof) 的文章，但如果您可以使用类似的东西证明您的帐户中有X个BTC而没有透露任何其他内容，可能就是你要找的东西。
>
> 我只是担心你想要的在理论上是不可能的。

### 回复：不是一个建议

> 发帖者：Red，2010年8月10日，下午05:29:44
> ————————————————————————————————————————————————————
> &emsp; &emsp; 引自：Insti于2010年8月10日，下午03:06:16
>
> 虽然我最近阅读的是零知识证明[http://en.wikipedia.org/wiki/Zero-knowledge_proof](http://en.wikipedia.org/wiki/Zero-knowledge_proof)
> ————————————————————————————————————————————————————
> 有趣的想法重新审视！谢谢。有一段时间没有想到它们。

### 回复：不是一个建议

> **发帖者：中本聪，2010年8月11日，上午12:14:22**
> ————————————————————————————————————————————————————
> **这是一个非常有趣的话题。如果找到解决方案，可以实现更好，更简单，更方便的比特币实现。**
>
> **本质上，币可以看作一连串的签名。使用时间戳服务，旧的可以在有太多的回溯扇出之前被丢弃，或者币可以单独保存或以面额保存。为了检查是否双重支付，需要全所有交易的全局知识。**
>
> **挑战在于，您如何证明不存在其他支出？似乎节点必须知道能够验证的所有交易。如果它只知道输入/输出点的哈希值，则无法检查签名以查看之前是否已经使用了一个端点。你有什么想法吗？**
>
> **在这种情况下，很难想到如何应用零知识证明。**
>
> **我们试图证明缺少某些东西，这似乎需要了解所有内容并检查是否包含某些内容。**

### 回复：不是一个建议

> 发帖者：Red，2010年8月11日，上午04:58:50
> ————————————————————————————————————————————————————
> 中本聪：我知道你知道我帖子内容的第一部分，但我希望其他人能够跟随并纠正我可能存在的任何误解。
>
> 我正在查看当前的Merkle树实现，试图找出何时可以删除交易而不会失去安全性。
>
> 在交易图形术语中，事务表示节点。交易图的边缘由入点表示，这些入点使用BlockHash->TransHash->OutPoint类型的结构指向先前的交易。存在一个标志着前一个出点的入点。
>
> 因此，为了使交易有效，您最常显示的是交易中的每个入点，即前一个出点存在并且不存在引用该出点的先前入点。因此，对于每个出点，都有零或一个入点指向它。零=未花费。一个=花费。
>
> 这也意味着不会从区块列表中剔除任何交易，直到它们的两个出点都用完为止。否则币将消失。
>
> 但是，只要您确信第二个绑定的区块将会存在，就可以删除所有双重绑定事务。(最早的可能性)
>
> 但是，当您删除交易并将其替换为树哈希时，会丢失区块列表中的图形结构。实际上，从区块列表中取消删除的所有事务都具有未使用的值，纯粹是因为它们仍然存在。它们不再能证明祖先的有效性，因为该图的那部分被剔除了。
>
> 让我思考的是，如果你从未将整个交易放入图表中，有没有办法证明有效性？
> ————————————————————————————————————————————————————
> **引自：中本聪，2010年8月11日，上午12:14:22**
>
> **挑战在于，您如何证明不存在其他支出？似乎节点必须知道能够验证的所有交易。如果它只知道输入/输出点的哈希值，则无法检查签名以查看之前是否已经使用了一个端点。你有什么想法吗？**
> ————————————————————————————————————————————————————
> 关键是将交易信息哈希为出点哈希的一部分。因此，您不是创建单个交易哈希，而是将交易表示为两个出点哈希。(我最初考虑使用哈希的入点/事务/出点结构，但事实证明这是不必要的。)
>
> 只有交易的验证者需要知道与记录的出点哈希相关联的比特币地址。这来自于当前交易的入点提交的父交易。如果该哈希值在区块列表中出现一次且仅一次，则父交易和输出点被哈希并且假定都有效且未使用。
>
> 当前的交易当然必须由父交易中的地址密钥签名。如果证明有效，则生成两个新的出点哈希并插入当前区块。通过将它们包含在当前区块中来标记入点的哈希值。(如果哈希存在两次，则会花费。)如果要将交易表示为一个单元（以及当前可见的交易图），则可以对入内哈希和出点哈希进行分组。但是，这并不是证明有效性的必要条件。
> ————————————————————————————————————————————————————
> **引自：中本聪，2010年8月11日，上午12:14:22**
>
> **我们试图证明缺少某些东西，这似乎需要了解所有内容并检查是否包含某些内容。**
> ————————————————————————————————————————————————————
> 在这种情况下，我们试图证明存在一个匹配的哈希并且缺失两个匹配的哈希。它需要知道所有交易，这些都需要证明。
>
> 我认为双重支出的禁令与当前版本一样强烈。
>
> ====小心！ ====
>
> 但是，您必须考虑节点因故意添加随机“取消哈希”而导致恶作剧的情况。在这种情况下，节点将无法访问币，因为他没有签名的交易哈希到有效的未使用的出点哈希。但是，目前的所有者也无法花钱，入点将假定已经花费了。
>
> 这意味着验证条件与当前实现完全相同。所有验证节点必须先检查并验证块中表示的所有交易，然后再接受它并在其上构建。
>
> 如果区块中存在任何未由有效交易表示的哈希值，则必须拒绝该区块。这与当前系统完全相同，如果任何交易未验证，则必须拒绝该区块。
>
> 我曾希望条件将所有交易传递给所有人验证者可能会被削弱，但我不知道如何(还)不依赖于可信委托。
> 
> ——————————
>
> 一个有趣的特性是，这简化了验证过程。所有需要做的就是解析区块列表(哈希)一次。在解析每个哈希时，您只需在哈希集中查找它。如果它不存在，则添加它。如果它确实存在，则删除它。解析区块列表后，您将拥有最小的有效和未使用的出点集。您甚至可以将整个集保留在内存中。(至少有一段时间！)
> ————————————————————————————————————————————————————
> **引自：中本聪，2010年8月11日，上午12:14:22**
>
> **在这种情况下，很难想到如何应用零知识证明。**
> ————————————————————————————————————————————————————
> 这对我来说也很难！虽然重读很有趣！
> 
> 希望它能够在节点上产生一些洞察力，以证明他们“始终遵循”区块生成规则，而不是每个人都需要对所有交易的集合进行双重检查。
>
> 它没有。 :-)

### 回复：不是一个建议

> 发帖者：中本聪，2010年8月11日，下午09:07:59
> **仍在思考这个想法.....**
>
> **网络唯一需要做的工作就是判断一个出点的花费是否是第一个。**
> 
> **如果我们愿意让客户保留自己的历史记录，那么网络可能不需要存储某些信息，例如：**
>
> * **价值**
> * **一次交易中的内点和外点的关联**
>
> **该网络将跟踪一堆独立的出点。它不知道它们属于哪些交易或金额。客户端可以查明是否已经花费了一个出点，并且它可以提交一个令人满意的入点来标记花费。网络保留了出点和证明它花费的第一个有效的入点。入点标记其相关的下一个出点和要素的哈希值，因此如果你知道要素，它可以私下显示签名签署一个特定的下一个出点，但公开网络不知道下一个出点是什么。**
>
> **我相信客户必须保留原始生成币的整个历史。发送付款的人必须向收件人发送数据，并且仍然与网络通信以标记花费的点数，并检查支出是否是第一笔支出。也许数据传输可以作为电子邮件附件完成。**
>
> **客户必须保留整个历史记录的事实降低了隐私权益。处理大量资金的人仍然会看到很多交易历史。以回溯的方式，他们可能最终会看到大部分的历史。可以精确地计算面额以限制扇出，但处理大量资金的业务可能最终会看到很多历史。**

### 回复：不是一个建议

> 发帖者：Red，2010年8月12日，上午01:10:19
> ————————————————————————————————————————————————————
> &emsp; &emsp; 引自：中本聪于2010年8月11日，下午09:07)59
>
> &emsp; &emsp; 仍在思考这个想法通过......
> ————————————————————————————————————————————————————
> 这是一个大脑扭曲的想法不是它。 :-)
>
> 事实证明，取消公证的概念很好地概括了。
>
> 例如，该系统不限于比特币交易。由于签署的合同是外部保留的，并附有其他验证/公证规则，因此您可以轻松实施IOU/索赔检查等操作。
>
> 如果有人给你5美元，你可以给他5美元的欠条。它的IOU哈希将被公证到区块列表中(哈希)。当你还清他们时，你可以让他们签署IOU进行确认。然后让公证人插入IOU哈希取消。然后，没有人可以显示备忘录副本并要求双重付款。
>
> &emsp; &emsp; 引自：中本聪，2010年8月11日，下午09:07:59
> ————————————————————————————————————————————————————
> &emsp; &emsp; 我相信客户必须将整个历史记录保留回原始生成的币。客户必须保留整个历史记录的事实降低了隐私权益。
> ————————————————————————————————————————————————————
> 起初我也这么想过。但后来我说服了自己。
>
> 这实际上取决于您对验证者和验证过程的信任程度。人们喜欢温暖的模糊，每一笔交易都可以让他们追溯他们的钱根源于它的创造。但是，这不是必需的。
>
> 如果您对在区块创建期间验证交易的过程有信心(>50％CPU协议)。如果您确信以前的块无法更改(您证明了这一点)。然后你只需要检查没有花掉相关的出点。安全功能仍然存在区块列表和过程中，即使交易本身存储在外部并且根本没有存储前驱。您通过证明可以使用Merkle树删除旧交易来自己展示这一点以保持一致性。
>
> &emsp; &emsp; 引自：中本聪，2010年8月11日，下午09:07:59
> ————————————————————————————————————————————————————
> 处理大量资金的人仍然会看到很多交易历史。它回顾性地扇出的方式，最终可能会看到大部分的历史。可以精确地计算面额以限制扇出，但处理大量资金的业务可能最终会看到很多历史。
>
> 诚然，隐私与可观察性直接相关。如果有一个像货币兑换商这样的中央政党，他可以提出许多不和之处。但是，如果我们摆脱每一枚硬币必须追溯到创造的观念，那么观察视野就会更加接近。
>
> ——————
>
> 真的很奇怪习惯这个硬币有效的概念，因为这个过程不会让它被包括在内。但实际上，这正是比特币生成的方式。交易没有输入，但是每个人都认为出点必须纯粹是有效的，否则，它根本就不在块中。 :-)：

### 回复：不是一个建议

> 发帖者：中本聪，2010年8月12日，上午02:46:56
> ————————————————————————————————————————————————————
> &emsp; &emsp; 引自：Red，2010年8月12日，上午01:10:19
> ————————————————————————————————————————————————————
> &emsp; &emsp; &emsp; &emsp; 引自：中本聪，2010年8月11日，下午09:07:59
> ————————————————————————————————————————————————————
> &emsp; &emsp; &emsp; &emsp; 我相信客户必须将整个历史记录保留回原始生成的币。客户必须保留整个历史记录的事实降低了隐私权益。
> ————————————————————————————————————————————————————
> &emsp; &emsp; 起初我也这么想过。但后来我说服了自己。
> ————————————————————————————————————————————————————
> **你是要回去谈论现有的比特币系统吗？**
>
> **我正在谈论的是我描述的假设系统，如果网络不知道交易的价值和历史，那么它无法验证它们并为它们担保，因此客户必须保留历史记录全部回来的路。**
> 
> **如果客户直到最近才出现，那么有两种方法说服别人交易过去是有效的：**
> **1. 将整个历史记录显示回原始生成的币。**
> **2. 将历史记录显示回一个彻底深刻的区块，然后相信如果有这么多节点都表示历史记录是正确的那么它必须是真的。**
>
> **但是，如果网络不知道交易的所有价值和历史，第二种方法无法实施，我不认为**

### 回复：不是一个建议

> 发帖者：Red，2010年8月12日，上午04:25:51
> ————————————————————————————————————————————————————
> &emsp; &emsp; 引自：中本聪，2010年8月12日，上午02:46:56
> ————————————————————————————————————————————————————
> &emsp; &emsp; &emsp; &emsp; 引自：Red，2010年8月12日，上午01:10:19
>
> &emsp; &emsp; &emsp; &emsp; 起初我也这么想过。但后来我说服了自己。
> ————————————————————————————————————————————————————
> &emsp; &emsp; 你这里是在谈论现有的比特币系统吗？
> ————————————————————————————————————————————————————
> 是的，我在谈论假设的系统。
> 
> 我提出系统的方式，每次生成一个区块时，每个验证节点必须通过验证交易并确认区块中的哈希值来接受或拒绝该区块。实际上，与当前系统完成的工作相同，加上出点哈希检查。由于其他验证者已经通过竞争生成了区块，因此它们已经(至少大部分)交易。
>
> 与当前系统一样，如果交易未验证(包括加上匹配的出点哈希)，则其他节点将拒绝该区块。如果区块没有被至少50％的CPU功率接受，则它不会成为区块列表。
>
> 因此，区块列表中存在哈希值表示当时至少有50％的现有验证程序查看并验证了所有包含的事务和出点哈希值。
>
> 因此（禁止哈希崩溃）如果某人提交了与未使用的出点相匹配的父交易，则该交易必须有效。
>
> 该父交易的父交易也必须是有效的，否则该父交易将被拒绝。等等等等。
>
> 对于那种情况并非如此，你必须假设有一段时间没有使用针对出点哈希验证区块。但是CPU竞争系统似乎难以置信。
> ————————————————————————————————————————————————————
> &emsp; &emsp; 引自：中本聪，2010年8月12日，上午02:46:56
>
> &emsp; &emsp; 如果客户直到最近才出现，那么说服交易有效过去的两种方法是：
>
> &emsp; &emsp; 1. 将整个历史记录显示回原始生成的币。
>
> &emsp; &emsp; 2. 将历史记录显示回一个彻底深刻的区块，然后相信如果有这么多节点都表示历史记录是正确的那么它必须是真的。
> 
> &emsp; &emsp; 如果客户最近加入了网络，那么它假定先前的验证者遵循规则并且所有预先存在的区块都是有效的。(没有人会加入已知腐朽的网络)
>
> &emsp; &emsp; 当然，在当前系统中，如果交易从未被清除，则新节点可以验证所有先前的区块以实现自我一致性。但他们仍然无法证明绝对真实。僵尸网络本可以接管并删除一些交易，留下“新事实”和不满意的用户。相当于上述情况1。
>
> &emsp; &emsp; 在当前系统中，如果交易是Merkle树清除，那么你有上面的情况2。新来者必须信任这个过程。任何遗漏，他们不需要担心。每个人都必须假定它是有效的。
>
> &emsp; &emsp; 我所说的独特之处在于，如果你对比特币验证竞赛过程充满信心（我们确实做到了！），那么你真的不需要“彻底深度区块”这一过程。有人在另一个帖子中说客户拒绝对超过两个小时的区块进行任何更改。因此，我们可以对12深埋的所有区块都有绝对的信心。
>
> &emsp; &emsp; 因此，如果一笔交易未花费并埋葬12深，我们可以清除它的所有历史。他们添加温暖的模糊，但没有额外的验证。我们必须依靠它们，根本没有办法备份和改变课程。
>
> &emsp; &emsp; 之后，每个后续区块都假定所有前面的区块都是真实的。否则它将是一个分叉而不是一个后续的区块。因此，对于针对前一个区块中的出点验证的任何交易，如果这些出点存在且未使用，则必须假定它们是有效的。如果这些被认为是有效的，那么即使被清除，他们的祖先也必须被推定为有效。
>
> 在所提出的系统中，完全相同的事情都是正确的。
>
> 如果一个先行的出点哈希是未花费的并埋藏了12个深度，那么它绝对是未花费的。没有什么可以改变这个事实。没有必要检查它的祖先。您可以完成验证交易，取消入点哈希并创建新的出点哈希。
> 
> 有趣的是，如果一个先行的出点哈希是未花费的并且埋没了不到12区块的深度，那么它就是相对未花费的。奇怪的是，检查它的祖先仍然没有意义。唯一可以改变祖先有效性的是分支交换到更长的链。如果是先前的祖先你正在验证此交易是否已被换出，此交易也将被换出。
>
> 这是那些俗气的时间机器电影情节之一。有人回到过去，花了我的祖先。现在我不存在！
>
> =====
> 
> 所以我所说的是，在两个系统(现有的和假设的)中，验证者唯一需要做的就是验证先行出点是否存在并且是未使用的(对于当前的区块链)。该过程确保其他所有内容保持相对或绝对有效。
>
> 其余的只是温暖的模糊。
>
> -  PS  - 
>
> 我知道这太冗长多余了，但我很厌倦编辑。:-)







